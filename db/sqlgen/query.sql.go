// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: query.sql

package sqlgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getChatEvents = `-- name: GetChatEvents :many
with chat_events as (
  select id, time, mission_id, soldier_id, capture_frame, channel, from_name, sender_name, message, player_uid
  from chat_events
  where mission_id = $1::int
    and capture_frame BETWEEN $3::int AND $4::int
  order by capture_frame asc
)
Select ce.id, ce.time, ce.mission_id, ce.soldier_id, ce.capture_frame, ce.channel, ce.from_name, ce.sender_name, ce.message, ce.player_uid
from soldiers s
  left join chat_events ce on s.id = ce.soldier_id
where s.mission_id = $1::int
  and s.ocap_id = $2::int
`

type GetChatEventsParams struct {
	MissionID  int32 `json:"missionId"`
	OcapID     int32 `json:"ocapId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

type GetChatEventsRow struct {
	ID           pgtype.Int8        `json:"id"`
	Time         pgtype.Timestamptz `json:"time"`
	MissionID    pgtype.Int8        `json:"missionId"`
	SoldierID    pgtype.Int8        `json:"soldierId"`
	CaptureFrame pgtype.Int8        `json:"captureFrame"`
	Channel      pgtype.Text        `json:"channel"`
	FromName     pgtype.Text        `json:"fromName"`
	SenderName   pgtype.Text        `json:"senderName"`
	Message      pgtype.Text        `json:"message"`
	PlayerUid    pgtype.Text        `json:"playerUid"`
}

// desc: Get chat events by mission id
func (q *Queries) GetChatEvents(ctx context.Context, arg GetChatEventsParams) ([]GetChatEventsRow, error) {
	rows, err := q.db.Query(ctx, getChatEvents,
		arg.MissionID,
		arg.OcapID,
		arg.StartFrame,
		arg.EndFrame,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChatEventsRow
	for rows.Next() {
		var i GetChatEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.SoldierID,
			&i.CaptureFrame,
			&i.Channel,
			&i.FromName,
			&i.SenderName,
			&i.Message,
			&i.PlayerUid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEntities = `-- name: GetEntities :many
Select id,
  ocap_id,
  ocap_type
FROM soldiers
WHERE mission_id = $1::int
UNION
Select id,
  ocap_id,
  ocap_type
from vehicles
WHERE mission_id = $1::int
`

type GetEntitiesRow struct {
	ID       int64       `json:"id"`
	OcapID   pgtype.Int4 `json:"ocapId"`
	OcapType pgtype.Text `json:"ocapType"`
}

// desc: Get all entities from a mission
func (q *Queries) GetEntities(ctx context.Context, missionID int32) ([]GetEntitiesRow, error) {
	rows, err := q.db.Query(ctx, getEntities, missionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEntitiesRow
	for rows.Next() {
		var i GetEntitiesRow
		if err := rows.Scan(&i.ID, &i.OcapID, &i.OcapType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFiredEvents = `-- name: GetFiredEvents :many
with fired_events AS (
  select id, time, mission_id, soldier_id, capture_frame, weapon, magazine, firing_mode, start_position, start_elevation_asl, end_position, end_elevation_asl
  from fired_events
  where mission_id = $1::int
    and capture_frame BETWEEN $3::int AND $4::int
  order by capture_frame asc
)
Select fe.id, fe.time, fe.mission_id, fe.soldier_id, fe.capture_frame, fe.weapon, fe.magazine, fe.firing_mode, fe.start_position, fe.start_elevation_asl, fe.end_position, fe.end_elevation_asl
from soldiers s
  left join fired_events fe on s.id = fe.soldier_id
where s.mission_id = $1::int
  and s.ocap_id = $2::int
`

type GetFiredEventsParams struct {
	MissionID  int32 `json:"missionId"`
	OcapID     int32 `json:"ocapId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

type GetFiredEventsRow struct {
	ID                pgtype.Int8        `json:"id"`
	Time              pgtype.Timestamptz `json:"time"`
	MissionID         pgtype.Int8        `json:"missionId"`
	SoldierID         pgtype.Int8        `json:"soldierId"`
	CaptureFrame      pgtype.Int8        `json:"captureFrame"`
	Weapon            pgtype.Text        `json:"weapon"`
	Magazine          pgtype.Text        `json:"magazine"`
	FiringMode        pgtype.Text        `json:"firingMode"`
	StartPosition     pgtype.Point       `json:"startPosition"`
	StartElevationAsl pgtype.Numeric     `json:"startElevationAsl"`
	EndPosition       pgtype.Point       `json:"endPosition"`
	EndElevationAsl   pgtype.Numeric     `json:"endElevationAsl"`
}

// desc: Get fired events by mission id and ocap id
func (q *Queries) GetFiredEvents(ctx context.Context, arg GetFiredEventsParams) ([]GetFiredEventsRow, error) {
	rows, err := q.db.Query(ctx, getFiredEvents,
		arg.MissionID,
		arg.OcapID,
		arg.StartFrame,
		arg.EndFrame,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFiredEventsRow
	for rows.Next() {
		var i GetFiredEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.SoldierID,
			&i.CaptureFrame,
			&i.Weapon,
			&i.Magazine,
			&i.FiringMode,
			&i.StartPosition,
			&i.StartElevationAsl,
			&i.EndPosition,
			&i.EndElevationAsl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHitEvents = `-- name: GetHitEvents :many
with hit_events as (
  select id, time, mission_id, capture_frame, victim_id_soldier, victim_id_vehicle, shooter_id_soldier, shooter_id_vehicle, event_text, distance
  from hit_events
  where mission_id = $1::int
    and capture_frame BETWEEN $3::int AND $4::int
  order by capture_frame asc
)
Select he.id, he.time, he.mission_id, he.capture_frame, he.victim_id_soldier, he.victim_id_vehicle, he.shooter_id_soldier, he.shooter_id_vehicle, he.event_text, he.distance
from soldiers s
  left join hit_events he on s.id IN (he.victim_id_soldier, he.shooter_id_soldier)
where s.mission_id = $1::int
  and s.ocap_id = $2::int
`

type GetHitEventsParams struct {
	MissionID  int32 `json:"missionId"`
	OcapID     int32 `json:"ocapId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

type GetHitEventsRow struct {
	ID               pgtype.Int8        `json:"id"`
	Time             pgtype.Timestamptz `json:"time"`
	MissionID        pgtype.Int8        `json:"missionId"`
	CaptureFrame     pgtype.Int8        `json:"captureFrame"`
	VictimIDSoldier  pgtype.Int8        `json:"victimIdSoldier"`
	VictimIDVehicle  pgtype.Int8        `json:"victimIdVehicle"`
	ShooterIDSoldier pgtype.Int8        `json:"shooterIdSoldier"`
	ShooterIDVehicle pgtype.Int8        `json:"shooterIdVehicle"`
	EventText        pgtype.Text        `json:"eventText"`
	Distance         pgtype.Numeric     `json:"distance"`
}

// desc: Get hit events by mission id
func (q *Queries) GetHitEvents(ctx context.Context, arg GetHitEventsParams) ([]GetHitEventsRow, error) {
	rows, err := q.db.Query(ctx, getHitEvents,
		arg.MissionID,
		arg.OcapID,
		arg.StartFrame,
		arg.EndFrame,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHitEventsRow
	for rows.Next() {
		var i GetHitEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.CaptureFrame,
			&i.VictimIDSoldier,
			&i.VictimIDVehicle,
			&i.ShooterIDSoldier,
			&i.ShooterIDVehicle,
			&i.EventText,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKillEvents = `-- name: GetKillEvents :many
with kill_events as (
  select id, time, mission_id, capture_frame, victim_id_soldier, victim_id_vehicle, killer_id_soldier, killer_id_vehicle, event_text, distance
  from kill_events
  where mission_id = $1::int
    and capture_frame BETWEEN $3::int AND $4::int
  order by capture_frame asc
)
Select ke.id, ke.time, ke.mission_id, ke.capture_frame, ke.victim_id_soldier, ke.victim_id_vehicle, ke.killer_id_soldier, ke.killer_id_vehicle, ke.event_text, ke.distance
from soldiers s
  left join kill_events ke on s.id IN (ke.victim_id_soldier, ke.killer_id_soldier)
where s.mission_id = $1::int
  and s.ocap_id = $2::int
`

type GetKillEventsParams struct {
	MissionID  int32 `json:"missionId"`
	OcapID     int32 `json:"ocapId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

type GetKillEventsRow struct {
	ID              pgtype.Int8        `json:"id"`
	Time            pgtype.Timestamptz `json:"time"`
	MissionID       pgtype.Int8        `json:"missionId"`
	CaptureFrame    pgtype.Int8        `json:"captureFrame"`
	VictimIDSoldier pgtype.Int8        `json:"victimIdSoldier"`
	VictimIDVehicle pgtype.Int8        `json:"victimIdVehicle"`
	KillerIDSoldier pgtype.Int8        `json:"killerIdSoldier"`
	KillerIDVehicle pgtype.Int8        `json:"killerIdVehicle"`
	EventText       pgtype.Text        `json:"eventText"`
	Distance        pgtype.Numeric     `json:"distance"`
}

// desc: Get kill events by mission id
func (q *Queries) GetKillEvents(ctx context.Context, arg GetKillEventsParams) ([]GetKillEventsRow, error) {
	rows, err := q.db.Query(ctx, getKillEvents,
		arg.MissionID,
		arg.OcapID,
		arg.StartFrame,
		arg.EndFrame,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKillEventsRow
	for rows.Next() {
		var i GetKillEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.CaptureFrame,
			&i.VictimIDSoldier,
			&i.VictimIDVehicle,
			&i.KillerIDSoldier,
			&i.KillerIDVehicle,
			&i.EventText,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMissionById = `-- name: GetMissionById :one
with sstates as (
  select mission_id,
    MAX(capture_frame) as last_frame
  from soldier_states
  group by mission_id
),
all_addons as (
  select a.id,
    a.name,
    a.workshop_id
  from addons a
  order by a.name asc
)
select m.id, m.created_at, m.updated_at, m.deleted_at, m.mission_name, m.briefing_name, m.mission_name_source, m.on_load_name, m.author, m.server_name, m.server_profile, m.start_time, m.world_id, m.capture_delay, m.addon_version, m.extension_version, m.extension_build, m.ocap_recorder_extension_version, m.tag,
  MAX(sstates.last_frame) as last_frame,
  array_agg(
    json_build_object(
      'addonName',
      ad.name,
      'workshopId',
      ad.workshop_id
    )
  ) as mods
from missions m
  left join sstates on sstates.mission_id = m.id
  left join all_addons ad on ad.id in (
    select addon_id
    from mission_addons
    where mission_id = $1::int
  )
where m.id = $1::int
group by m.id
`

type GetMissionByIdRow struct {
	ID                           int64              `json:"id"`
	CreatedAt                    pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt                    pgtype.Timestamptz `json:"updatedAt"`
	DeletedAt                    pgtype.Timestamptz `json:"deletedAt"`
	MissionName                  pgtype.Text        `json:"missionName"`
	BriefingName                 pgtype.Text        `json:"briefingName"`
	MissionNameSource            pgtype.Text        `json:"missionNameSource"`
	OnLoadName                   pgtype.Text        `json:"onLoadName"`
	Author                       pgtype.Text        `json:"author"`
	ServerName                   pgtype.Text        `json:"serverName"`
	ServerProfile                pgtype.Text        `json:"serverProfile"`
	StartTime                    pgtype.Timestamptz `json:"startTime"`
	WorldID                      pgtype.Int8        `json:"worldId"`
	CaptureDelay                 pgtype.Numeric     `json:"captureDelay"`
	AddonVersion                 pgtype.Text        `json:"addonVersion"`
	ExtensionVersion             pgtype.Text        `json:"extensionVersion"`
	ExtensionBuild               pgtype.Text        `json:"extensionBuild"`
	OcapRecorderExtensionVersion pgtype.Text        `json:"ocapRecorderExtensionVersion"`
	Tag                          pgtype.Text        `json:"tag"`
	LastFrame                    interface{}        `json:"lastFrame"`
	Mods                         interface{}        `json:"mods"`
}

// desc: Get mission by id
func (q *Queries) GetMissionById(ctx context.Context, missionID int32) (GetMissionByIdRow, error) {
	row := q.db.QueryRow(ctx, getMissionById, missionID)
	var i GetMissionByIdRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.MissionName,
		&i.BriefingName,
		&i.MissionNameSource,
		&i.OnLoadName,
		&i.Author,
		&i.ServerName,
		&i.ServerProfile,
		&i.StartTime,
		&i.WorldID,
		&i.CaptureDelay,
		&i.AddonVersion,
		&i.ExtensionVersion,
		&i.ExtensionBuild,
		&i.OcapRecorderExtensionVersion,
		&i.Tag,
		&i.LastFrame,
		&i.Mods,
	)
	return i, err
}

const getMissions = `-- name: GetMissions :many
Select id, created_at, updated_at, deleted_at, mission_name, briefing_name, mission_name_source, on_load_name, author, server_name, server_profile, start_time, world_id, capture_delay, addon_version, extension_version, extension_build, ocap_recorder_extension_version, tag
FROM missions
`

// desc: Get all missions
func (q *Queries) GetMissions(ctx context.Context) ([]Mission, error) {
	rows, err := q.db.Query(ctx, getMissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Mission
	for rows.Next() {
		var i Mission
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.MissionName,
			&i.BriefingName,
			&i.MissionNameSource,
			&i.OnLoadName,
			&i.Author,
			&i.ServerName,
			&i.ServerProfile,
			&i.StartTime,
			&i.WorldID,
			&i.CaptureDelay,
			&i.AddonVersion,
			&i.ExtensionVersion,
			&i.ExtensionBuild,
			&i.OcapRecorderExtensionVersion,
			&i.Tag,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOtherChatEvents = `-- name: GetOtherChatEvents :many
with chat_events as (
  select id, time, mission_id, soldier_id, capture_frame, channel, from_name, sender_name, message, player_uid
  from chat_events
  where mission_id = $1::int
    and capture_frame BETWEEN $2::int AND $3::int
  order by capture_frame asc
)
Select ce.id, ce.time, ce.mission_id, ce.soldier_id, ce.capture_frame, ce.channel, ce.from_name, ce.sender_name, ce.message, ce.player_uid
from chat_events ce
where ce.soldier_id IS NULL
  and ce.mission_id = $1::int
`

type GetOtherChatEventsParams struct {
	MissionID  int32 `json:"missionId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

// desc: Get other chat events by mission id
func (q *Queries) GetOtherChatEvents(ctx context.Context, arg GetOtherChatEventsParams) ([]ChatEvent, error) {
	rows, err := q.db.Query(ctx, getOtherChatEvents, arg.MissionID, arg.StartFrame, arg.EndFrame)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatEvent
	for rows.Next() {
		var i ChatEvent
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.SoldierID,
			&i.CaptureFrame,
			&i.Channel,
			&i.FromName,
			&i.SenderName,
			&i.Message,
			&i.PlayerUid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOtherRadioEvents = `-- name: GetOtherRadioEvents :many
with radio_events as (
  select id, time, mission_id, soldier_id, capture_frame, radio, radio_type, start_end, channel, is_additional, frequency, code
  from radio_events
  where mission_id = $1::int
    and capture_frame BETWEEN $2::int AND $3::int
  order by capture_frame asc
)
Select re.id, re.time, re.mission_id, re.soldier_id, re.capture_frame, re.radio, re.radio_type, re.start_end, re.channel, re.is_additional, re.frequency, re.code
from radio_events re
where re.soldier_id IS NULL
  and re.mission_id = $1::int
`

type GetOtherRadioEventsParams struct {
	MissionID  int32 `json:"missionId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

// desc: Get other radio events by mission id
func (q *Queries) GetOtherRadioEvents(ctx context.Context, arg GetOtherRadioEventsParams) ([]RadioEvent, error) {
	rows, err := q.db.Query(ctx, getOtherRadioEvents, arg.MissionID, arg.StartFrame, arg.EndFrame)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RadioEvent
	for rows.Next() {
		var i RadioEvent
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.SoldierID,
			&i.CaptureFrame,
			&i.Radio,
			&i.RadioType,
			&i.StartEnd,
			&i.Channel,
			&i.IsAdditional,
			&i.Frequency,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRadioEvents = `-- name: GetRadioEvents :many
with radio_events as (
  select id, time, mission_id, soldier_id, capture_frame, radio, radio_type, start_end, channel, is_additional, frequency, code
  from radio_events
  where mission_id = $1::int
    and capture_frame BETWEEN $3::int AND $4::int
  order by capture_frame asc
)
Select re.id, re.time, re.mission_id, re.soldier_id, re.capture_frame, re.radio, re.radio_type, re.start_end, re.channel, re.is_additional, re.frequency, re.code
from soldiers s
  left join radio_events re on s.id = re.soldier_id
where s.mission_id = $1::int
  and s.ocap_id = $2::int
`

type GetRadioEventsParams struct {
	MissionID  int32 `json:"missionId"`
	OcapID     int32 `json:"ocapId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

type GetRadioEventsRow struct {
	ID           pgtype.Int8        `json:"id"`
	Time         pgtype.Timestamptz `json:"time"`
	MissionID    pgtype.Int8        `json:"missionId"`
	SoldierID    pgtype.Int8        `json:"soldierId"`
	CaptureFrame pgtype.Int8        `json:"captureFrame"`
	Radio        pgtype.Text        `json:"radio"`
	RadioType    pgtype.Text        `json:"radioType"`
	StartEnd     pgtype.Text        `json:"startEnd"`
	Channel      pgtype.Int2        `json:"channel"`
	IsAdditional pgtype.Bool        `json:"isAdditional"`
	Frequency    pgtype.Numeric     `json:"frequency"`
	Code         pgtype.Text        `json:"code"`
}

// desc: Get radio events by mission id
func (q *Queries) GetRadioEvents(ctx context.Context, arg GetRadioEventsParams) ([]GetRadioEventsRow, error) {
	rows, err := q.db.Query(ctx, getRadioEvents,
		arg.MissionID,
		arg.OcapID,
		arg.StartFrame,
		arg.EndFrame,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRadioEventsRow
	for rows.Next() {
		var i GetRadioEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.SoldierID,
			&i.CaptureFrame,
			&i.Radio,
			&i.RadioType,
			&i.StartEnd,
			&i.Channel,
			&i.IsAdditional,
			&i.Frequency,
			&i.Code,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServerFpsEvents = `-- name: GetServerFpsEvents :many
Select sfe.time, sfe.mission_id, sfe.capture_frame, sfe.fps_average, sfe.fps_min
from server_fps_events sfe
where sfe.mission_id = $1::int
order by capture_frame asc
`

// desc: Get server fps events by mission id
func (q *Queries) GetServerFpsEvents(ctx context.Context, missionID int32) ([]ServerFpsEvent, error) {
	rows, err := q.db.Query(ctx, getServerFpsEvents, missionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ServerFpsEvent
	for rows.Next() {
		var i ServerFpsEvent
		if err := rows.Scan(
			&i.Time,
			&i.MissionID,
			&i.CaptureFrame,
			&i.FpsAverage,
			&i.FpsMin,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoldierById = `-- name: GetSoldierById :one
Select id, created_at, updated_at, deleted_at, mission_id, join_time, join_frame, ocap_id, ocap_type, unit_name, group_id, side, is_player, role_description, player_uid, class_name, display_name
FROM soldiers
WHERE mission_id = $1::int
  and ocap_id = $2::int
`

type GetSoldierByIdParams struct {
	MissionID int32 `json:"missionId"`
	OcapID    int32 `json:"ocapId"`
}

// desc: Get soldier by ocap id
func (q *Queries) GetSoldierById(ctx context.Context, arg GetSoldierByIdParams) (Soldier, error) {
	row := q.db.QueryRow(ctx, getSoldierById, arg.MissionID, arg.OcapID)
	var i Soldier
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.MissionID,
		&i.JoinTime,
		&i.JoinFrame,
		&i.OcapID,
		&i.OcapType,
		&i.UnitName,
		&i.GroupID,
		&i.Side,
		&i.IsPlayer,
		&i.RoleDescription,
		&i.PlayerUid,
		&i.ClassName,
		&i.DisplayName,
	)
	return i, err
}

const getSoldierByOcapId = `-- name: GetSoldierByOcapId :one
Select id, created_at, updated_at, deleted_at, mission_id, join_time, join_frame, ocap_id, ocap_type, unit_name, group_id, side, is_player, role_description, player_uid, class_name, display_name
FROM soldiers
WHERE mission_id = $1::int
  and ocap_id = $2::int
`

type GetSoldierByOcapIdParams struct {
	MissionID int32 `json:"missionId"`
	OcapID    int32 `json:"ocapId"`
}

// desc: Get soldier by ocap id
func (q *Queries) GetSoldierByOcapId(ctx context.Context, arg GetSoldierByOcapIdParams) (Soldier, error) {
	row := q.db.QueryRow(ctx, getSoldierByOcapId, arg.MissionID, arg.OcapID)
	var i Soldier
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.MissionID,
		&i.JoinTime,
		&i.JoinFrame,
		&i.OcapID,
		&i.OcapType,
		&i.UnitName,
		&i.GroupID,
		&i.Side,
		&i.IsPlayer,
		&i.RoleDescription,
		&i.PlayerUid,
		&i.ClassName,
		&i.DisplayName,
	)
	return i, err
}

const getSoldierStates = `-- name: GetSoldierStates :many
with ss as (
  select id, time, mission_id, capture_frame, soldier_id, position, elevation_asl, bearing, lifestate, in_vehicle, vehicle_role, unit_name, is_player, "current_role", has_stable_vitals, is_dragged_carried, scores_infantry_kills, scores_vehicle_kills, scores_armor_kills, scores_air_kills, scores_deaths, scores_total_score
  from soldier_states
  where mission_id = $1::int
    and capture_frame BETWEEN $3::int AND $4::int
  order by capture_frame asc
)
select s2.id, s2.time, s2.mission_id, s2.capture_frame, s2.soldier_id, s2.position, s2.elevation_asl, s2.bearing, s2.lifestate, s2.in_vehicle, s2.vehicle_role, s2.unit_name, s2.is_player, s2."current_role", s2.has_stable_vitals, s2.is_dragged_carried, s2.scores_infantry_kills, s2.scores_vehicle_kills, s2.scores_armor_kills, s2.scores_air_kills, s2.scores_deaths, s2.scores_total_score
from soldiers s
  left join ss s2 on s.id = s2.soldier_id
where s.mission_id = $1::int
  and s.ocap_id = $2::int
`

type GetSoldierStatesParams struct {
	MissionID  int32 `json:"missionId"`
	OcapID     int32 `json:"ocapId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

type GetSoldierStatesRow struct {
	ID                  pgtype.Int8        `json:"id"`
	Time                pgtype.Timestamptz `json:"time"`
	MissionID           pgtype.Int8        `json:"missionId"`
	CaptureFrame        pgtype.Int8        `json:"captureFrame"`
	SoldierID           pgtype.Int8        `json:"soldierId"`
	Position            pgtype.Point       `json:"position"`
	ElevationAsl        pgtype.Numeric     `json:"elevationAsl"`
	Bearing             pgtype.Int4        `json:"bearing"`
	Lifestate           pgtype.Int2        `json:"lifestate"`
	InVehicle           pgtype.Bool        `json:"inVehicle"`
	VehicleRole         pgtype.Text        `json:"vehicleRole"`
	UnitName            pgtype.Text        `json:"unitName"`
	IsPlayer            pgtype.Bool        `json:"isPlayer"`
	CurrentRole         pgtype.Text        `json:"currentRole"`
	HasStableVitals     pgtype.Bool        `json:"hasStableVitals"`
	IsDraggedCarried    pgtype.Bool        `json:"isDraggedCarried"`
	ScoresInfantryKills pgtype.Int2        `json:"scoresInfantryKills"`
	ScoresVehicleKills  pgtype.Int2        `json:"scoresVehicleKills"`
	ScoresArmorKills    pgtype.Int2        `json:"scoresArmorKills"`
	ScoresAirKills      pgtype.Int2        `json:"scoresAirKills"`
	ScoresDeaths        pgtype.Int2        `json:"scoresDeaths"`
	ScoresTotalScore    pgtype.Int2        `json:"scoresTotalScore"`
}

// desc: Get soldier states by mission id and ocap id
func (q *Queries) GetSoldierStates(ctx context.Context, arg GetSoldierStatesParams) ([]GetSoldierStatesRow, error) {
	rows, err := q.db.Query(ctx, getSoldierStates,
		arg.MissionID,
		arg.OcapID,
		arg.StartFrame,
		arg.EndFrame,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSoldierStatesRow
	for rows.Next() {
		var i GetSoldierStatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.CaptureFrame,
			&i.SoldierID,
			&i.Position,
			&i.ElevationAsl,
			&i.Bearing,
			&i.Lifestate,
			&i.InVehicle,
			&i.VehicleRole,
			&i.UnitName,
			&i.IsPlayer,
			&i.CurrentRole,
			&i.HasStableVitals,
			&i.IsDraggedCarried,
			&i.ScoresInfantryKills,
			&i.ScoresVehicleKills,
			&i.ScoresArmorKills,
			&i.ScoresAirKills,
			&i.ScoresDeaths,
			&i.ScoresTotalScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehicleByOcapId = `-- name: GetVehicleByOcapId :one
Select id, created_at, updated_at, deleted_at, mission_id, join_time, join_frame, ocap_id, ocap_type, class_name, display_name, customization
FROM vehicles
WHERE mission_id = $1::int
  and ocap_id = $2::int
`

type GetVehicleByOcapIdParams struct {
	MissionID int32 `json:"missionId"`
	OcapID    int32 `json:"ocapId"`
}

// desc: Get vehicle by ocap id
func (q *Queries) GetVehicleByOcapId(ctx context.Context, arg GetVehicleByOcapIdParams) (Vehicle, error) {
	row := q.db.QueryRow(ctx, getVehicleByOcapId, arg.MissionID, arg.OcapID)
	var i Vehicle
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.MissionID,
		&i.JoinTime,
		&i.JoinFrame,
		&i.OcapID,
		&i.OcapType,
		&i.ClassName,
		&i.DisplayName,
		&i.Customization,
	)
	return i, err
}

const getVehicleHitEvents = `-- name: GetVehicleHitEvents :many
with he as (
  select id, time, mission_id, capture_frame, victim_id_soldier, victim_id_vehicle, shooter_id_soldier, shooter_id_vehicle, event_text, distance
  from hit_events
  where mission_id = $1::int
    and capture_frame BETWEEN $3::int AND $4::int
  order by capture_frame asc
)
Select he.id, he.time, he.mission_id, he.capture_frame, he.victim_id_soldier, he.victim_id_vehicle, he.shooter_id_soldier, he.shooter_id_vehicle, he.event_text, he.distance
from vehicles v
  left join he on v.id = he.vehicle_id
where v.mission_id = $1::int
  and v.ocap_id = $2::int
`

type GetVehicleHitEventsParams struct {
	MissionID  int32 `json:"missionId"`
	OcapID     int32 `json:"ocapId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

type GetVehicleHitEventsRow struct {
	ID               pgtype.Int8        `json:"id"`
	Time             pgtype.Timestamptz `json:"time"`
	MissionID        pgtype.Int8        `json:"missionId"`
	CaptureFrame     pgtype.Int8        `json:"captureFrame"`
	VictimIDSoldier  pgtype.Int8        `json:"victimIdSoldier"`
	VictimIDVehicle  pgtype.Int8        `json:"victimIdVehicle"`
	ShooterIDSoldier pgtype.Int8        `json:"shooterIdSoldier"`
	ShooterIDVehicle pgtype.Int8        `json:"shooterIdVehicle"`
	EventText        pgtype.Text        `json:"eventText"`
	Distance         pgtype.Numeric     `json:"distance"`
}

// desc: Get vehicle hit events by mission id
func (q *Queries) GetVehicleHitEvents(ctx context.Context, arg GetVehicleHitEventsParams) ([]GetVehicleHitEventsRow, error) {
	rows, err := q.db.Query(ctx, getVehicleHitEvents,
		arg.MissionID,
		arg.OcapID,
		arg.StartFrame,
		arg.EndFrame,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehicleHitEventsRow
	for rows.Next() {
		var i GetVehicleHitEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.CaptureFrame,
			&i.VictimIDSoldier,
			&i.VictimIDVehicle,
			&i.ShooterIDSoldier,
			&i.ShooterIDVehicle,
			&i.EventText,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehicleKillEvents = `-- name: GetVehicleKillEvents :many
with ke as (
  select id, time, mission_id, capture_frame, victim_id_soldier, victim_id_vehicle, killer_id_soldier, killer_id_vehicle, event_text, distance
  from kill_events
  where mission_id = $1::int
    and capture_frame BETWEEN $3::int AND $4::int
  order by capture_frame asc
)
Select ke.id, ke.time, ke.mission_id, ke.capture_frame, ke.victim_id_soldier, ke.victim_id_vehicle, ke.killer_id_soldier, ke.killer_id_vehicle, ke.event_text, ke.distance
FROM vehicles v
  left join ke on v.id IN (ke.victim_id_vehicle, ke.killer_id_vehicle)
where v.mission_id = $1::int
  and v.ocap_id = $2::int
`

type GetVehicleKillEventsParams struct {
	MissionID  int32 `json:"missionId"`
	OcapID     int32 `json:"ocapId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

type GetVehicleKillEventsRow struct {
	ID              pgtype.Int8        `json:"id"`
	Time            pgtype.Timestamptz `json:"time"`
	MissionID       pgtype.Int8        `json:"missionId"`
	CaptureFrame    pgtype.Int8        `json:"captureFrame"`
	VictimIDSoldier pgtype.Int8        `json:"victimIdSoldier"`
	VictimIDVehicle pgtype.Int8        `json:"victimIdVehicle"`
	KillerIDSoldier pgtype.Int8        `json:"killerIdSoldier"`
	KillerIDVehicle pgtype.Int8        `json:"killerIdVehicle"`
	EventText       pgtype.Text        `json:"eventText"`
	Distance        pgtype.Numeric     `json:"distance"`
}

// desc: Get vehicle kill events by mission id
func (q *Queries) GetVehicleKillEvents(ctx context.Context, arg GetVehicleKillEventsParams) ([]GetVehicleKillEventsRow, error) {
	rows, err := q.db.Query(ctx, getVehicleKillEvents,
		arg.MissionID,
		arg.OcapID,
		arg.StartFrame,
		arg.EndFrame,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehicleKillEventsRow
	for rows.Next() {
		var i GetVehicleKillEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.CaptureFrame,
			&i.VictimIDSoldier,
			&i.VictimIDVehicle,
			&i.KillerIDSoldier,
			&i.KillerIDVehicle,
			&i.EventText,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVehicleStates = `-- name: GetVehicleStates :many
with vs as (
  select id, time, mission_id, capture_frame, vehicle_id, position, elevation_asl, bearing, is_alive, crew, fuel, damage, locked, engine_on, side
  from vehicle_states
  where mission_id = $1::int
    and capture_frame BETWEEN $3::int AND $4::int
  order by capture_frame asc
)
select v2.id, v2.time, v2.mission_id, v2.capture_frame, v2.vehicle_id, v2.position, v2.elevation_asl, v2.bearing, v2.is_alive, v2.crew, v2.fuel, v2.damage, v2.locked, v2.engine_on, v2.side
from vehicles v
  left join vs v2 on v.id = v2.vehicle_id
where v.mission_id = $1::int
  and v.ocap_id = $2::int
`

type GetVehicleStatesParams struct {
	MissionID  int32 `json:"missionId"`
	OcapID     int32 `json:"ocapId"`
	StartFrame int32 `json:"startFrame"`
	EndFrame   int32 `json:"endFrame"`
}

type GetVehicleStatesRow struct {
	ID           pgtype.Int8        `json:"id"`
	Time         pgtype.Timestamptz `json:"time"`
	MissionID    pgtype.Int8        `json:"missionId"`
	CaptureFrame pgtype.Int8        `json:"captureFrame"`
	VehicleID    pgtype.Int8        `json:"vehicleId"`
	Position     pgtype.Point       `json:"position"`
	ElevationAsl pgtype.Numeric     `json:"elevationAsl"`
	Bearing      pgtype.Int4        `json:"bearing"`
	IsAlive      pgtype.Bool        `json:"isAlive"`
	Crew         pgtype.Text        `json:"crew"`
	Fuel         pgtype.Numeric     `json:"fuel"`
	Damage       pgtype.Numeric     `json:"damage"`
	Locked       pgtype.Bool        `json:"locked"`
	EngineOn     pgtype.Bool        `json:"engineOn"`
	Side         pgtype.Text        `json:"side"`
}

// desc: Get vehicle states by mission id and ocap id
func (q *Queries) GetVehicleStates(ctx context.Context, arg GetVehicleStatesParams) ([]GetVehicleStatesRow, error) {
	rows, err := q.db.Query(ctx, getVehicleStates,
		arg.MissionID,
		arg.OcapID,
		arg.StartFrame,
		arg.EndFrame,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVehicleStatesRow
	for rows.Next() {
		var i GetVehicleStatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Time,
			&i.MissionID,
			&i.CaptureFrame,
			&i.VehicleID,
			&i.Position,
			&i.ElevationAsl,
			&i.Bearing,
			&i.IsAlive,
			&i.Crew,
			&i.Fuel,
			&i.Damage,
			&i.Locked,
			&i.EngineOn,
			&i.Side,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorldById = `-- name: GetWorldById :one
Select id, created_at, updated_at, deleted_at, author, workshop_id, display_name, world_name, world_name_original, world_size, location
FROM worlds
WHERE id = $1::int
`

// desc: Get world by id
func (q *Queries) GetWorldById(ctx context.Context, worldID int32) (World, error) {
	row := q.db.QueryRow(ctx, getWorldById, worldID)
	var i World
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Author,
		&i.WorkshopID,
		&i.DisplayName,
		&i.WorldName,
		&i.WorldNameOriginal,
		&i.WorldSize,
		&i.Location,
	)
	return i, err
}

const getWorlds = `-- name: GetWorlds :many
Select id, created_at, updated_at, deleted_at, author, workshop_id, display_name, world_name, world_name_original, world_size, location
FROM worlds
`

// desc: Get all worlds
func (q *Queries) GetWorlds(ctx context.Context) ([]World, error) {
	rows, err := q.db.Query(ctx, getWorlds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []World
	for rows.Next() {
		var i World
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Author,
			&i.WorkshopID,
			&i.DisplayName,
			&i.WorldName,
			&i.WorldNameOriginal,
			&i.WorldSize,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
